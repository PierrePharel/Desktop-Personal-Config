// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Wnck {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Tasklist]
	public class Tasklist : Gtk.Container {

		public Tasklist(IntPtr raw) : base(raw) {}

		[DllImport("wnck-1", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr wnck_tasklist_new(IntPtr screen);

		public Tasklist (Wnck.Screen screen) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Tasklist)) {
				throw new InvalidOperationException ("Can't override this constructor.");
			}
			owned = true;
			Raw = wnck_tasklist_new(screen == null ? IntPtr.Zero : screen.Handle);
		}

		[DllImport("wnck-1", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr wnck_tasklist_get_type();

		static GLib.GType _gtype = new GLib.GType (wnck_tasklist_get_type());
		public static new GLib.GType GType { 
			get {
								return _gtype;
			}
		}

		[DllImport("wnck-1", CallingConvention = CallingConvention.Cdecl)]
		static extern void wnck_tasklist_set_button_relief(IntPtr raw, int relief);

		public Gtk.ReliefStyle ButtonRelief { 
			set {
				wnck_tasklist_set_button_relief(Handle, (int) value);
			}
		}

		[DllImport("wnck-1", CallingConvention = CallingConvention.Cdecl)]
		static extern void wnck_tasklist_set_grouping(IntPtr raw, int grouping);

		public Wnck.TasklistGroupingType Grouping { 
			set {
				wnck_tasklist_set_grouping(Handle, (int) value);
			}
		}

		[DllImport("wnck-1", CallingConvention = CallingConvention.Cdecl)]
		static extern void wnck_tasklist_set_switch_workspace_on_unminimize(IntPtr raw, bool switch_workspace_on_unminimize);

		public bool SwitchWorkspaceOnUnminimize { 
			set {
				wnck_tasklist_set_switch_workspace_on_unminimize(Handle, value);
			}
		}

		[DllImport("wnck-1", CallingConvention = CallingConvention.Cdecl)]
		static extern void wnck_tasklist_set_include_all_workspaces(IntPtr raw, bool include_all_workspaces);

		public bool IncludeAllWorkspaces { 
			set {
				wnck_tasklist_set_include_all_workspaces(Handle, value);
			}
		}

		[DllImport("wnck-1", CallingConvention = CallingConvention.Cdecl)]
		static extern void wnck_tasklist_set_grouping_limit(IntPtr raw, int limit);

		public int GroupingLimit { 
			set {
				wnck_tasklist_set_grouping_limit(Handle, value);
			}
		}

		[DllImport("wnck-1", CallingConvention = CallingConvention.Cdecl)]
		static extern void wnck_tasklist_set_icon_loader(IntPtr raw, WnckSharp.LoadIconFunctionNative load_icon_func, IntPtr data, GLib.DestroyNotify free_data_func);

		public Wnck.LoadIconFunction IconLoader { 
			set {
				WnckSharp.LoadIconFunctionWrapper value_wrapper = new WnckSharp.LoadIconFunctionWrapper (value);
				IntPtr data;
				GLib.DestroyNotify free_data_func;
				if (value == null) {
					data = IntPtr.Zero;
					free_data_func = null;
				} else {
					data = (IntPtr) GCHandle.Alloc (value_wrapper);
					free_data_func = GLib.DestroyHelper.NotifyHandler;
				}
				wnck_tasklist_set_icon_loader(Handle, value_wrapper.NativeDelegate, data, free_data_func);
			}
		}

#endregion
	}

	internal class TasklistAttribute : GLib.GTypeTypeAttribute {
		[DllImport ("wnck-1", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr wnck_tasklist_get_type ();

		private static GLib.GType _gtype = new GLib.GType (wnck_tasklist_get_type ());
		public static GLib.GType GType { get { return _gtype; } }
		public override GLib.GType Type { get { return _gtype; } }

	}
}
